// generated by Fast Light User Interface Designer (fluid) version 1.0300

#include "midi_gate_widget.h"

void MidiGateUI::cb_hold_i(psiDialX* o, void*) {
  hold_out->value(o->value());
adsr_box->sustain(hold->value());
writePort( int(MIDIGATE_HOLD),o->value());
}
void MidiGateUI::cb_hold(psiDialX* o, void* v) {
  ((MidiGateUI*)(o->parent()->user_data()))->cb_hold_i(o,v);
}

void MidiGateUI::cb_attack_i(psiDialX* o, void*) {
  attack_out->value(o->value());
adsr_box->attack(attack->value());
writePort( int(MIDIGATE_ATTACK),o->value());
}
void MidiGateUI::cb_attack(psiDialX* o, void* v) {
  ((MidiGateUI*)(o->parent()->user_data()))->cb_attack_i(o,v);
}

void MidiGateUI::cb_release_i(psiDialX* o, void*) {
  release_out->value(o->value());
adsr_box->release(release->value());
writePort( int(MIDIGATE_DECAY),o->value());
}
void MidiGateUI::cb_release(psiDialX* o, void* v) {
  ((MidiGateUI*)(o->parent()->user_data()))->cb_release_i(o,v);
}

void MidiGateUI::cb_attack_out_i(Fl_Value_Input* o, void*) {
  attack->value(o->value());
writePort( int(MIDIGATE_ATTACK),o->value());
adsr_box->attack(attack_out->value());
}
void MidiGateUI::cb_attack_out(Fl_Value_Input* o, void* v) {
  ((MidiGateUI*)(o->parent()->user_data()))->cb_attack_out_i(o,v);
}

void MidiGateUI::cb_hold_out_i(Fl_Value_Input* o, void*) {
  hold->value(o->value());
adsr_box->sustain(hold_out->value());
writePort( int(MIDIGATE_HOLD),o->value());
}
void MidiGateUI::cb_hold_out(Fl_Value_Input* o, void* v) {
  ((MidiGateUI*)(o->parent()->user_data()))->cb_hold_out_i(o,v);
}

void MidiGateUI::cb_release_out_i(Fl_Value_Input* o, void*) {
  release->value(o->value());
adsr_box->release(release_out->value());
writePort( int(MIDIGATE_DECAY),o->value());
}
void MidiGateUI::cb_release_out(Fl_Value_Input* o, void* v) {
  ((MidiGateUI*)(o->parent()->user_data()))->cb_release_out_i(o,v);
}

void MidiGateUI::cb_range_i(Fl_Slider* o, void*) {
  range_out->value(o->value());
adsr_box->set_range(range_out->value());
writePort( int(MIDIGATE_RANGE),o->value());
}
void MidiGateUI::cb_range(Fl_Slider* o, void* v) {
  ((MidiGateUI*)(o->parent()->user_data()))->cb_range_i(o,v);
}

void MidiGateUI::cb_noteon_i(Fl_Light_Button* o, void*) {
  if (o->value()==1) {
   writePort(int(MIDIGATE_PROGRAM),0);
   noteoff->value(0);	
} else {
   writePort(int(MIDIGATE_PROGRAM),1);
   noteoff->value(1);	
};
}
void MidiGateUI::cb_noteon(Fl_Light_Button* o, void* v) {
  ((MidiGateUI*)(o->parent()->user_data()))->cb_noteon_i(o,v);
}

void MidiGateUI::cb_noteoff_i(Fl_Light_Button* o, void*) {
  if (o->value()==1) {
   writePort(int(MIDIGATE_PROGRAM),1);
   noteon->value(0);	
} else {
   writePort(int(MIDIGATE_PROGRAM),0);
   noteon->value(1);	
};
}
void MidiGateUI::cb_noteoff(Fl_Light_Button* o, void* v) {
  ((MidiGateUI*)(o->parent()->user_data()))->cb_noteoff_i(o,v);
}

void MidiGateUI::cb_select_i(Fl_Light_Button* o, void*) {
  writePort( int(MIDIGATE_SELECT),o->value());
}
void MidiGateUI::cb_select(Fl_Light_Button* o, void* v) {
  ((MidiGateUI*)(o->parent()->user_data()))->cb_select_i(o,v);
}

void MidiGateUI::cb_range_out_i(Fl_Value_Input* o, void*) {
  range->value(o->value());
adsr_box->set_range(range_out->value());
writePort( int(MIDIGATE_RANGE),o->value());
}
void MidiGateUI::cb_range_out(Fl_Value_Input* o, void* v) {
  ((MidiGateUI*)(o->parent()->user_data()))->cb_range_out_i(o,v);
}

void MidiGateUI::update_button(int button) {
}

MidiGateUI::MidiGateUI() {
  { window = new Fl_Double_Window(365, 240);
    window->color((Fl_Color)48);
    window->user_data((void*)(this));
    { Fl_Box* o = new Fl_Box(290, 77, 30, 1);
      o->box(FL_EMBOSSED_FRAME);
      o->color((Fl_Color)80);
      o->selection_color((Fl_Color)80);
    } // Fl_Box* o
    { psiLabelBox* o = new psiLabelBox(0, 0, 365, 240, "psi MIDI Gate");
      o->box(FL_NO_BOX);
      o->color(FL_BACKGROUND_COLOR);
      o->selection_color((Fl_Color)80);
      o->labeltype(FL_NORMAL_LABEL);
      o->labelfont(0);
      o->labelsize(14);
      o->labelcolor(FL_FOREGROUND_COLOR);
      o->align(Fl_Align(FL_ALIGN_CENTER));
      o->when(FL_WHEN_RELEASE);
      o->label_align( 125, 15, LBL_LEFT, 5, 10, BOX_NORMAL);
    } // psiLabelBox* o
    { hold = new psiDialX(90, 140, 50, 50, "Hold");
      hold->tooltip("The time the gate is kept open");
      hold->box(FL_NO_BOX);
      hold->color(FL_DARK_RED);
      hold->selection_color(FL_INACTIVE_COLOR);
      hold->labeltype(FL_NORMAL_LABEL);
      hold->labelfont(0);
      hold->labelsize(10);
      hold->labelcolor(FL_FOREGROUND_COLOR);
      hold->maximum(2000);
      hold->step(1);
      hold->value(100);
      hold->callback((Fl_Callback*)cb_hold);
      hold->align(Fl_Align(514));
      hold->when(FL_WHEN_CHANGED);
    } // psiDialX* hold
    { attack = new psiDialX(25, 140, 50, 50, "Attack");
      attack->tooltip("The time it takes to fully open the gate after once a note-on is recieved");
      attack->box(FL_NO_BOX);
      attack->color(FL_DARK_RED);
      attack->selection_color(FL_INACTIVE_COLOR);
      attack->labeltype(FL_NORMAL_LABEL);
      attack->labelfont(0);
      attack->labelsize(10);
      attack->labelcolor(FL_FOREGROUND_COLOR);
      attack->maximum(1000);
      attack->step(1);
      attack->value(20);
      attack->callback((Fl_Callback*)cb_attack);
      attack->align(Fl_Align(FL_ALIGN_BOTTOM));
      attack->when(FL_WHEN_CHANGED);
    } // psiDialX* attack
    { release = new psiDialX(155, 140, 50, 50, "Release");
      release->tooltip("The time it takes to release the gate once the hold time has been attained");
      release->box(FL_NO_BOX);
      release->color(FL_DARK_RED);
      release->selection_color(FL_INACTIVE_COLOR);
      release->labeltype(FL_NORMAL_LABEL);
      release->labelfont(0);
      release->labelsize(10);
      release->labelcolor(FL_FOREGROUND_COLOR);
      release->minimum(1);
      release->maximum(4000);
      release->step(1);
      release->value(50);
      release->callback((Fl_Callback*)cb_release);
      release->align(Fl_Align(FL_ALIGN_BOTTOM));
      release->when(FL_WHEN_CHANGED);
      //release->pixmap(new Fl_XPM_Image("UI/knob-metal1.png"));
      release->type(Fl_Dial::PIXMAP_DIAL);
    } // psiDialX* release
    { Fl_Value_Input* o = attack_out = new Fl_Value_Input(30, 205, 40, 20);
      attack_out->box(FL_DOWN_BOX);
      attack_out->color(FL_BACKGROUND2_COLOR);
      attack_out->selection_color(FL_SELECTION_COLOR);
      attack_out->labeltype(FL_NORMAL_LABEL);
      attack_out->labelfont(0);
      attack_out->labelsize(14);
      attack_out->labelcolor(FL_FOREGROUND_COLOR);
      attack_out->maximum(1000);
      attack_out->step(1);
      attack_out->value(20);
      attack_out->textsize(10);
      attack_out->callback((Fl_Callback*)cb_attack_out);
      attack_out->align(Fl_Align(FL_ALIGN_RIGHT));
      attack_out->when(FL_WHEN_CHANGED);
      o->visible_focus(0);
    } // Fl_Value_Input* attack_out
    { Fl_Value_Input* o = hold_out = new Fl_Value_Input(95, 205, 40, 20);
      hold_out->box(FL_DOWN_BOX);
      hold_out->color(FL_BACKGROUND2_COLOR);
      hold_out->selection_color(FL_SELECTION_COLOR);
      hold_out->labeltype(FL_NORMAL_LABEL);
      hold_out->labelfont(0);
      hold_out->labelsize(14);
      hold_out->labelcolor(FL_FOREGROUND_COLOR);
      hold_out->maximum(2000);
      hold_out->step(1);
      hold_out->value(100);
      hold_out->textsize(10);
      hold_out->callback((Fl_Callback*)cb_hold_out);
      hold_out->align(Fl_Align(FL_ALIGN_RIGHT));
      hold_out->when(FL_WHEN_CHANGED);
      o->visible_focus(0);
    } // Fl_Value_Input* hold_out
    { Fl_Value_Input* o = release_out = new Fl_Value_Input(160, 205, 40, 20);
      release_out->tooltip("The time it takes to release the gate once the hold time has been attained");
      release_out->box(FL_DOWN_BOX);
      release_out->color(FL_BACKGROUND2_COLOR);
      release_out->selection_color(FL_SELECTION_COLOR);
      release_out->labeltype(FL_NORMAL_LABEL);
      release_out->labelfont(0);
      release_out->labelsize(14);
      release_out->labelcolor(FL_FOREGROUND_COLOR);
      release_out->maximum(4000);
      release_out->step(1);
      release_out->value(20);
      release_out->textsize(10);
      release_out->callback((Fl_Callback*)cb_release_out);
      release_out->align(Fl_Align(FL_ALIGN_RIGHT));
      release_out->when(FL_WHEN_CHANGED);
      o->visible_focus(0);
    } // Fl_Value_Input* release_out
    { Fl_Slider* o = range = new Fl_Slider(295, 40, 20, 165);
      range->tooltip("The amount of signal reduction when the gate is closed (dB)");
      range->box(FL_ROUND_UP_BOX);
      range->color(FL_BACKGROUND_COLOR);
      range->selection_color(FL_BACKGROUND_COLOR);
      range->labeltype(FL_NORMAL_LABEL);
      range->labelfont(0);
      range->labelsize(10);
      range->labelcolor(FL_FOREGROUND_COLOR);
      range->minimum(20);
      range->maximum(-70);
      range->step(1);
      range->value(-25);
      range->callback((Fl_Callback*)cb_range);
      range->align(Fl_Align(FL_ALIGN_TOP));
      range->when(FL_WHEN_CHANGED);
      o->visible_focus(0);
    } // Fl_Slider* range
    { Fl_Light_Button* o = noteon = new Fl_Light_Button(220, 145, 60, 20, "Note On");
      noteon->tooltip("Open the gate on MIDI Note On");
      noteon->value(1);
      noteon->selection_color((Fl_Color)80);
      noteon->labelsize(10);
      noteon->callback((Fl_Callback*)cb_noteon);
      o->visible_focus(0);
    } // Fl_Light_Button* noteon
    { psi::PeakMeter* o = level = new psi::PeakMeter(330, 40, 20, 165);
      level->box(FL_ROUND_UP_BOX);
      level->color(FL_BACKGROUND_COLOR);
      level->selection_color(FL_BACKGROUND_COLOR);
      level->labeltype(FL_NORMAL_LABEL);
      level->labelfont(0);
      level->labelsize(10);
      level->labelcolor(FL_FOREGROUND_COLOR);
      level->minimum(6);
      level->maximum(-70);
      level->value(-70);
      level->align(Fl_Align(FL_ALIGN_TOP));
      level->when(FL_WHEN_CHANGED);
      o->visible_focus(0);
    } // psi::PeakMeter* level
    { Fl_Light_Button* o = noteoff = new Fl_Light_Button(220, 165, 60, 20, "Note Off");
      noteoff->tooltip("Open the gate on MIDI Note Off");
      noteoff->selection_color(FL_DARK_RED);
      noteoff->labelsize(10);
      noteoff->callback((Fl_Callback*)cb_noteoff);
      o->visible_focus(0);
    } // Fl_Light_Button* noteoff
    { Fl_Light_Button* o = gate_state = new Fl_Light_Button(220, 10, 60, 20, "Open");
      gate_state->tooltip("The current gate state");
      gate_state->box(FL_ROUND_UP_BOX);
      gate_state->value(1);
      gate_state->selection_color(FL_DARK_RED);
      gate_state->labelsize(10);
      gate_state->when(FL_WHEN_RELEASE_ALWAYS);
      o->visible_focus(0);
    } // Fl_Light_Button* gate_state
    { Fl_Light_Button* o = select = new Fl_Light_Button(155, 10, 60, 20, "Bypass");
      select->selection_color(FL_DARK_RED);
      select->labelsize(10);
      select->callback((Fl_Callback*)cb_select);
      o->visible_focus(0);
    } // Fl_Light_Button* select
    { psi::Envelope* o = adsr_box = new psi::Envelope(10, 40, 270, 90);
      adsr_box->box(FL_THIN_UP_BOX);
      adsr_box->color(FL_BACKGROUND_COLOR);
      adsr_box->selection_color(FL_BACKGROUND_COLOR);
      adsr_box->labeltype(FL_NO_LABEL);
      adsr_box->labelfont(0);
      adsr_box->labelsize(14);
      adsr_box->labelcolor(FL_FOREGROUND_COLOR);
      adsr_box->align(Fl_Align(514));
      adsr_box->when(FL_WHEN_RELEASE);
      o->set_range(-70.0f,20.0f,7000.0f,-25.0f);
    } // psi::Envelope* adsr_box
    { Fl_Value_Input* o = range_out = new Fl_Value_Input(295, 205, 20, 20);
      range_out->tooltip("The amount of signal reduction when the gate is closed (dB)");
      range_out->box(FL_DOWN_BOX);
      range_out->color(FL_BACKGROUND2_COLOR);
      range_out->selection_color(FL_SELECTION_COLOR);
      range_out->labeltype(FL_NORMAL_LABEL);
      range_out->labelfont(0);
      range_out->labelsize(14);
      range_out->labelcolor(FL_FOREGROUND_COLOR);
      range_out->minimum(20);
      range_out->maximum(-70);
      range_out->step(1);
      range_out->value(-25);
      range_out->textsize(10);
      range_out->callback((Fl_Callback*)cb_range_out);
      range_out->align(Fl_Align(FL_ALIGN_RIGHT));
      range_out->when(FL_WHEN_CHANGED);
      o->visible_focus(0);
    } // Fl_Value_Input* range_out
    { Fl_Output* o = new Fl_Output(325, 10, 5, 24, "Range");
      o->box(FL_NO_BOX);
      o->labelsize(10);
      o->align(Fl_Align(68));
    } // Fl_Output* o
    { Fl_Output* o = new Fl_Output(350, 11, 5, 24, "Db");
      o->box(FL_NO_BOX);
      o->labelsize(10);
      o->align(Fl_Align(68));
    } // Fl_Output* o
    { Fl_Output* o = new Fl_Output(265, 186, 5, 24, "Trigger");
      o->box(FL_NO_BOX);
      o->labelsize(10);
      o->align(Fl_Align(68));
    } // Fl_Output* o
    { Fl_Value_Input* o = level_out = new Fl_Value_Input(330, 205, 20, 20);
      level_out->box(FL_DOWN_BOX);
      level_out->color(FL_BACKGROUND_COLOR);
      level_out->selection_color(FL_BACKGROUND_COLOR);
      level_out->labeltype(FL_NORMAL_LABEL);
      level_out->labelfont(0);
      level_out->labelsize(14);
      level_out->labelcolor(FL_FOREGROUND_COLOR);
      level_out->minimum(-70);
      level_out->maximum(6);
      level_out->step(1);
      level_out->value(-70);
      level_out->textsize(10);
      level_out->align(Fl_Align(FL_ALIGN_BOTTOM_RIGHT));
      level_out->when(FL_WHEN_CHANGED);
      o->visible_focus(0);
    } // Fl_Value_Input* level_out
    Fl_Theme::set( "Gleam");
          Fl_Tooltip::color(FL_BLACK);
          Fl_Tooltip::textcolor(221);
          Fl_Tooltip::size(11);

          Fl_Dial::default_style(Fl_Dial::PIXMAP_DIAL);
          Fl_PNG_Image* dial_image = new Fl_PNG_Image( LV2_DIR "/midi_gate-psi.lv2/knob.png");
          Fl_Image* dimage = dial_image->copy();
          psiDialX::default_image(dimage);
    window->end();
    window->resizable(window);
  } // Fl_Double_Window* window
}

void MidiGateUI::idle() {
  Fl::check();
  Fl::flush();
}

int MidiGateUI::getWidth() {
  return window->w();
}

int MidiGateUI::getHeight() {
  return window->h();
}

void MidiGateUI::writePort(int port, float value) {
  write_function(controller, port, sizeof(float), 0, &value);
}
